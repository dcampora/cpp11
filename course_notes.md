
## C++11 course notes

I missed 7.3 to 7.7.

* captain obvious

In-place new

    new (data+size) int{n};

    Wow. So... you can first allocate for ints, like

    int* data = new (20*sizeof(int)) int;

    And then, if you want to allocate a dynamic object in
    that memory location:

    new (data+some_location) int(my_int);


"Rubber duck debugging"
    When explaining to a colleague "Yes, so I have that problem... blablabla... ah!",
    and you get the answer just by explaining. So we should have a rubber duck, to
    whom explain the problem, next to the screen.


"class invariance"
    Refers to the goodness of an instance's attributes (contracts being respected).
    For instance, for a vector class instance, it would mean the size equals the
    numbers of elements in the array inside. This must be preserved between calls,
    not necessarily between intra-instance calls.

explicit keyword?

anonymous scopes (C++98)
    We can create a scope just by putting {} **anywhere** in our code.

Consider there are TWO CONCEPTS. VERY important.
    - "lvalue" or "rvalue".
    - BOUND to an "lvalue" or BOUND to an "rvalue".

    // t has an lvalue (obviously, has a name).
    // t is bound to an rvalue.
    T&& t = a();

    // x has an lvalue.
    // x is bound to an lvalue.
    // we can use it as an rvalue (std::move(x))
    T& x = a();

    // hehe.
    // y has an lvalue.
    // y is bound to... we don't know!
    // y is a "universal reference"
    // we can use it as an rvalue, I guess,
    //  I don't know what happens when doing std::move(x) on 
    //  a variable bound to an rvalue.
    template<class T>
    T&& y = a();
    // OR
    auto&& y = a();

    // For this last case, we can use std::forward,
    //  exercise "perfect forwarding" (copy or move).

    // Another thing to note is, we can't generate a
    //  templated function **only** for rvalues.
    // ie.
    template<class T>
    void foo(T&& t);

    // Necessarily, foo will be instantiated even if we
    //  call with a Type& instead of a Type&&.
    // Weird, since we can do the other way round.

* decltype

"decltype instructs the compiler to use type information from arbitrarily distant declaration".

I can get the type at **compile time** by using decltype.


There are helpers for decltype, all sorts of tricks can be done.
For instance, if there is a type which is not known, because it's not known
what constructor is being used for UnknownType (I don't fully understand, it's very twisted):

decltype(std::declval<UnknownType>().member()) c = ...; // Doesn't require any specific constructor


* clang

Apart from a compiler, there are tools available to do header parsing,
remove redundant header includes and so on.


* uniform initialization syntax (awesome!)

The {} operators are used as a uniform initialization syntax.


* initialization order is important (ugly)
  Order is always base constructors, 

struct A {
    A();
    A(int);
};

struct B : A {
    int a;
    int b;

    B() : b(3), a(b), A() {} // Terrible
    B() : b(3), a(b), A(a) {} // Super terrible
};

* Constructor delegation

We can delegate the constructor in C++11, with "using Base::Base;"
inside the class.

* List of constructors -> 9.1

* POD

// This is not POD (user-defined)
struct A { A(){} }

// This is POD (user-declared)
struct A { A() = default; }

// Hmm? The second one has a default "A(const A&)" ...


* 10.1 is awesome, and I still don't like const...


* Lambdas :D

    [ __captured__ ]( __variables__ )->__return_type__{ __code__ }

You can pass a lambda with no captured parameters
to a legacy function (ie. C library).

Note: __return_type__ is optional, lambdas usually get the return type.
    __variables__ is optional, we don't even need the ().

Lambdas are behind the scenes functors. Unless they don't capture
anything, in which case they are functions.

11.9 is the code generated by the compiler when compiling a lambda function (awesome).

We can use "mutable" for modifying (creating a copy) of a variable passed by value.

* Return value optimization

13.1


* rvalues have changed a bit

There is a move operator in C++11, which allows for moving things, leaving the
original one in a "destructible" state.

Uf, ok, several things to write down.

Copy is a fallback to move, and we don't control this. (Not). (At all).
So even when writing std::move, it could be the case the program is
running the copy operator (if the move constructor / assignment is not implemented).

There are thus 5 conceptually different constructors, the first three are
for sure generated automatically (the other two we are not sure).

Normal constructor (parameter-free)
Copy constructor
Copy assignment constructor
Move constructor
Move assignment constructor


**Anything with a name has an lvalue**

eg.

T a;
T& b = a;
T&& c = a;
// What's the difference between b and c? None.
// Both are named things, on a function call
// it makes a difference.

// ie. (this being defined before)
void foo(T&);
void foo(T&&);

foo(b); // Call to first foo
foo(c); // Call to second foo
foo(std::move(b)); // Call to second foo.


Super important sentence
**Any variable name is an lvalue, even if its formal type is rvalue reference.**

// ie.
void foo(T&& t){
    // t has a name, therefore it is an lvalue.
    // In order to call an rvalue thing, do std::move(t)
}


* auto_ptr

Don't use it (easy).

* copy and swap

In the copy operator, instead of receiving the thing by reference,
now implement by receiving by value and passing that to the object.

    // eg. (C++98)
    struct Foo {
      Foo& operator=(Foo local_copy) {// NB By VALUE! We want a copy to be made here.
        swap(*this, local_copy);
        return *this;
      }
    };

13.12 refers to using a function defined outside the class, so as not
to implement redundant code on several classes (ie. swapping).

    // Good habit: use ADL on swap, it will work with nonstandard types
    // (such as the one we are writing right now)
    using std::swap; 


* Universal references

Term inventeed by Scott Myers, not in the C++11 ref.

* New good practice

If we want to copy something, rather than passing the thing by
reference and doing an explicit copy, pass it by value and move it.
The compiler may move it for us automatically.
13.17.10

In other words, "move enable" our classes.

* Emplacement

Instead of push_back, we could move in C++11. Or even better, just
create the object where it's supposed to go! :) This is emplacement.

RAII - Resource Allocation In Initialization (there's some god taking care of resources)
- smart pointers (garbage collection)
- concurrency (guards)


* Falling back on other types (probably there's a better name for it)

shared_ptr.cpp
    // dcampora: std::move is not doing anything here. 
    // take_shared_by_reference takes a reference (F&),
    // so it "falls back" to that overloaded function definition.
    take_shared_by_reference(std::move(f));

Essentially, careful with types falling back to other types, because of
type-whatever. ie.

    void foo(float a);
    ...
    int a = 20;
    foo(a); // works, "a" falls back to float.

The same for rvalue bound variables,
    
    void foo(T& a);
    ...
    T&& b = t;
    foo(b); // works

    // or
    T b;
    foo(std::move(b)); // works (move is like a static_cast<T&&>(b))

* There's unique_ptr and shared_ptr. Like in OSG, use them. Love them :)

* There's also weak_ptr. It notifies when a shared_ptr is deleted.

* Read the summary (19), very good.


